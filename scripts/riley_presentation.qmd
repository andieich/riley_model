---
title: "Riley 1946"
execute:
  freeze: auto
format:
  html:
      theme: flatly
---

## Setup

Load packages

```{r}
#| warning: false
#| message: false

library(here)
library(deSolve)
library(patchwork)
library(mgcv)
library(tidyverse)
```

Load forcing data

```{r}
dat_forc <- read.csv(here("data", "forcing.csv")) %>%
  mutate(days = days + 1) # data is 0 base (1.1. corresponds to day 0)

dat_obs <- read.csv(here("data", "observed.csv"))
```

## First Model

Define parameters

```{r}
parameters <- list(
  p = 2.5, # gC(gC)^-1 d^-1
  I_min = 0.0015, # g cal cm^-2 min^-1
  r = 0.069, # °C^-1 (Q10=2, Why 0.69 in Excel???)
  R_0 = 0.0175, # day^-1
  g = 0.0075, # day^-1
  # forcing data
  forcing = dat_forc
)
```

Define first model version. Use `approx()` to interpolate forcing data for each time point. For now, use `rule = 2` so that for time points outside of the period in forcing data values are returned.

```{r}
m_riley <- function(time, state, parameters) {
  with(as.list(c(state, parameters)), {
    # helper function to interpolate frocing data
    get_approx <- function(parameter) {
      y_val <- approx(
        x = dat_forc$days,
        y = dat_forc[[parameter]],
        xout = time,
        rule = 2
      )$y
      # catch NA values and stop execution
      if (is.na(y_val)) {
        stop(sprintf(
          "Interpolation failed for '%s' at time %s",
          parameter,
          time
        ))
      }
      return(y_val)
    }

    # interpolate at "time"
    dat_forc <- forcing

    I_0_t <- max(get_approx("I_0"), I_min * 1.0001) #  avoid I_0 < I_min which would lead to division by 0 (z_eup => 0, used in photos equation)
    k_t <- max(get_approx("k"), 1e-6) # avoid possibel 0 division in z_euph formula
    L_N_t <- get_approx("L_N")
    z_mix_t <- get_approx("z_mix")
    temp_t <- get_approx("temp")
    zoo_bm_t <- get_approx("zoo_bm")

    # Euphotic depth
    z_euph <- log(I_0_t / I_min) / k_t

    # Light limitation
    L_V <- if (z_euph < z_mix_t) z_euph / z_mix_t else 1

    photos <- (p * I_0_t) /
      (k_t * z_euph) *
      (1 - exp(-k_t * z_euph)) *
      L_N_t *
      L_V

    resp <- R_0 * exp(r * temp_t)
    graz <- g * zoo_bm_t

    dPhyto_bm <- (photos - resp - graz) * Phyto_bm

    list(
      dPhyto_bm,
      photos = photos,
      resp = resp,
      graz = graz
    )
  })
}
```

Define initial conditions

```{r}
state <- c(Phyto_bm = 3.377)
```

Time period to be integrated. Use 15 days because starting value is one time step (originally 15 days) before start of model.

> **Hint:** This leads to `approx()` using the 1st forcing data point for -15 days. See below for improvement. Use interval of 1 day instead of 15 days.

```{r}
times <- seq(-15, 365, 1)
```

Run the model

```{r}
solution <- ode(
  y = state,
  times = times,
  func = m_riley,
  parms = parameters
)
```


Plot the integrated data

::::: columns
::: {.column width="50%"}
```{r}
plot_phytop <- solution %>%
  as_tibble() %>%
  filter(time > 0) %>%
  ggplot(aes(x = time, y = Phyto_bm)) +
  geom_area(fill = "lightblue") +
  geom_point(data = dat_obs) +
  labs(x = "Days", y = expression("Phytoplankton biomass (gC " * m^-2 * ")")) +
  theme_light()
```

:::

::: {.column width="50%"}
```{r}
#| warning: false
#| message: false
#| echo: false
#| label: fig-phyto_m1
#| fig-cap: "Modelled phytoplankton biomass"

plot_phytop
```

:::
:::::

Plot the rates

> Annoyingly, `ggplot()` can’t make stacked area plots like Excel. `geom_ribbon` with the explicit values have to be used.


```{r}
#| warning: false
#| message: false
#| echo: false
#| label: fig-rates_m1
#| fig-cap: "Modelled production rates"

plot_rates <- solution %>%
  as.data.frame() %>%
  filter(time > 0) %>%
  ggplot(aes(x = time)) +
  geom_ribbon(
    aes(
      ymin = photos - resp,
      ymax = photos,
      fill = "Respiration"
    )
  ) +
  # green: respiration→net layer
  geom_ribbon(
    aes(
      ymin = photos - resp - graz,
      ymax = photos - resp,
      fill = "Grazing"
    )
  ) +
  scale_fill_manual(
    name = NULL,
    values = c(
      "Respiration" = "#5095d4",
      "Grazing" = "#125a52"
    )
  ) +
  geom_line(
    aes(y = photos - resp - graz, linetype = "Net Production"),
    linewidth = .7
  ) +
  geom_line(
    aes(y = photos, linetype = "Gross Production"),
    linewidth = .7
  ) +
  geom_hline(yintercept = 0, linetype = "11", col = "grey30") +
  scale_linetype_manual(
    name = NULL,
    values = c("Net Production" = "solid", "Gross Production" = "11")
  ) +
  labs(
    x = "Days",
    y = expression(
      "Specific rate (d"^{
        -1
      } *
        ")"
    )
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  theme_light()
plot_rates
```


## Alternative Interpolation

As seen in @fig-rates_m1, some predictions are quite 'jaggy'. This is probably due to the linear approximations used for the forcing varaibles. Additionally, using the next value for timepoints outside of the range of the forcing data set (start = -15 days, end = 365 days) is not ideal.

As an alternative, use "cyclic" GAMs. Cyclic means here, that the end of the data is 'conncted' to the start.

Although GAMs are fitted only once outside of the model function, the prediction step takes much more time than `approx()`. 

Fit a GAM for each parameter:

```{r}
gam_list <- list()
vars <- c("I_0", "k", "L_N", "z_mix", "temp", "zoo_bm")

for (v in vars) {
  form <- bquote(.(as.name(v)) ~ s(days, k = .(nrow(dat_forc)), bs = "cc"))
  gam_list[[v]] <- gam(
    formula = form,
    data = dat_forc,
    family = Gamma(link = "log"),
    method = "REML",
    knots = list(days = c(0.5, 365.5))
  )
}
```

Use these GAMs in `parameters`:

```{r}
parameters_g <- list(
  # parameters
  p = 2.5, # gC(gC)^-1 d^-1
  I_min = 0.0015, # g cal cm^-2 min^-1
  r = 0.069, # °C^-1 OR 0.69???
  R_0 = 0.0175, # day^-1
  g = 0.0075, # day^-1
  # forcing GAMs
  forcing_gams = gam_list
)
```

Update model code


```{r}
m_riley_g <- function(time, state, parameters) {
  with(as.list(c(state, parameters)), {
    # helper function to predict data with GAMs
    get_predict <- function(parameter) {
      predict(forcing_gams[[parameter]], newdata = data.frame(days = time)) %>%
        # log link was used, predictions on log scale
        exp()
    }

    I_0_t <- max(get_predict("I_0"), I_min * 1.0001) #  avoid I_0 < I_min which would lead to division by 0 (z_eup => 0, used in photos equation)
    k_t <- max(get_predict("k"), 1e-6) # avoid possibel 0 division in z_euph formula
    L_N_t <- get_predict("L_N")
    z_mix_t <- get_predict("z_mix")
    temp_t <- get_predict("temp")
    zoo_bm_t <- get_predict("zoo_bm")

    # Euphotic depth
    z_euph <- log(I_0_t / I_min) / k_t

    # Light limitation
    L_V <- if (z_euph < z_mix_t) z_euph / z_mix_t else 1

    photos <- (p * I_0_t) /
      (k_t * z_euph) *
      (1 - exp(-k_t * z_euph)) *
      L_N_t *
      L_V

    resp <- R_0 * exp(r * temp_t)
    graz <- g * zoo_bm_t

    dPhyto_bm <- (photos - resp - graz) * Phyto_bm

    list(
      dPhyto_bm,
      photos = photos,
      resp = resp,
      graz = graz
    )
  })
}
```

Now, solve as before


```{r}
solution_g <- ode(
  y = state,
  times = times,
  func = m_riley_g,
  parms = parameters_g
)
```

Plot pyhtoplankton biomass for both methods


```{r}
#| warning: false
#| message: false
#| echo: false
#| label: fig-phyto_comparison
#| fig-cap: "Modelled phytoplankton biomass with `approx()` and GAMS"

solution %>%
  as.data.frame() %>%
  filter(time > 0) %>%
  select(time, approx = Phyto_bm) %>%
  left_join(
    solution_g %>%
      as.data.frame() %>%
      filter(time > 0) %>%
      select(time, GAM = Phyto_bm)
  ) %>%
  pivot_longer(approx:GAM) %>%
  ggplot(aes(x = time)) +
  geom_line(aes(y = value, col = name), linewidth = .7) +
  geom_point(data = dat_obs, aes(y = Phyto_bm)) +
  labs(
    x = "Days",
    y = expression("Phytoplankton biomass (gC " * m^-2 * ")"),
    col = NULL
  ) +
  scale_colour_manual(values = c("#be5523", "#a7a8ec")) +
  theme_light()
```

Plot the rates next to each other


```{r}
#| warning: false
#| message: false
#| echo: false
#| label: fig-rates_g
#| fig-cap: "Compare modelled production rates"

#for some reason, ".1" is added to some column names in solution_g. Quick fix:
colnames(solution_g) <- colnames(solution)

plot_rates_g <- solution_g %>%
  as.data.frame() %>%
  filter(time > 0) %>%
  ggplot(aes(x = time)) +
  geom_ribbon(
    aes(
      ymin = photos - resp,
      ymax = photos,
      fill = "Respiration"
    )
  ) +
  # green: respiration→net layer
  geom_ribbon(
    aes(
      ymin = photos - resp - graz,
      ymax = photos - resp,
      fill = "Grazing"
    )
  ) +
  scale_fill_manual(
    name = NULL,
    values = c(
      "Respiration" = "#5095d4",
      "Grazing" = "#125a52"
    )
  ) +
  geom_line(
    aes(y = photos - resp - graz, linetype = "Net Production"),
    linewidth = .7
  ) +
  geom_line(
    aes(y = photos, linetype = "Gross Production"),
    linewidth = .7
  ) +
  geom_hline(yintercept = 0, linetype = "11", col = "grey30") +
  scale_linetype_manual(
    name = NULL,
    values = c("Net Production" = "solid", "Gross Production" = "11")
  ) +
  labs(
    x = "Days",
    y = expression(
      "Specific rate (d"^{
        -1
      } *
        ")"
    )
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  theme_light()


plot_rates +
  ggtitle("approx()") +
  plot_rates_g +
  ggtitle("GAM") +
  plot_layout(guides = "collect")
```